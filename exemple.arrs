/*Bob possède un mur divisé en N sections. Il lui arrive de repeidre Ki sections adjacentes, a savoir les sections Ii à Ji. On demandera, après R repeintes, de donner le nombre de fois que chaque section à été repeinte.

Entrée:
N un entier, le nombre de sections
R un entier, le nombre de repeintes
sur les R lignes suivantes :
Ii et Ji deux entiers séparés par un espace : les index de début et de fin de l'intervalle repeinte (0-indexed)*/


struct bad_struct {
    num a,b
    list c
}

struct bad_struct2 {
    num a,b
    list c
}

operator ("op", "goodname", 5, "{a} op {b}"){
    return Null
}

operator ("S", "s_combinator" , 0, "S {f} {g} {x}"){
    return lambda x: f(x, g(x))
}

operator ("S", "s_combinator_2" , 0, "S §{f} §{g} {x}"){
    return lambda x: f(x, g(x))
}

operator ("op2", "goodname2" , 9.7,"op2 {a}"){
    return Null
}

func dummy(num a){
    return Null
}

func dummy2(num a, b; list c){
    variable = nom[5:9][]+90**2
    return Null
}

a = (1 + 3 * (5 + input::input()))

func main(){
    N = num::input()
    R = num::input()
    sections = array(N, num) # N:nombre d'items, num: type
    for i in range(R){
        I, J = num..split::input()
        sections[I]--
        sections[J]++
    }
    sections = + -> sections
    output(" " -+- str..sections)
    output(a op op2 b)
    S + - aze
}

output(123)

input.output()

I, J = num..split::input()